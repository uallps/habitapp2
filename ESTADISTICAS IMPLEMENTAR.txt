# IMPLEMENTACIÓN (Codex) — Plugin de Estadísticas (Recaps) para app de hábitos en Swift (MVVM)

Eres un agente de implementación (Codex). Tu tarea es **implementar** una feature modular de **Estadísticas (Recaps)** en una aplicación existente de hábitos escrita en **Swift**, siguiendo estrictamente el estilo y convenciones ya presentes en el repositorio.

> **Regla #1:** Antes de escribir código, inspecciona el proyecto y detecta:  
> - si usa **SwiftUI o UIKit**,  
> - cómo organiza **MVVM** (nombres de carpetas, naming, routers/coordinators, DI actual),  
> - cómo persiste datos (CoreData/SwiftData/Realm/SQLite/etc),  
> - cómo se definen `Habit`, completions, schedule/frecuencia y la navegación de tabs.  
> Luego implementa **imitando el estilo actual**.
- Puede ser una tarea larga de implementar, pero asegurate de que lo implementes bien.

---

## 0) Objetivo del plugin
Añadir una pestaña **Estadísticas** con una experiencia tipo *recap* (Spotify/YouTube) que permita:
- Previsualizar rápidamente el rendimiento del usuario.
- Entrar a recaps detallados por periodo: **Diario, Semanal, Mensual, Anual**.
- Entender **Completed vs Expected** según la frecuencia real de cada hábito.

Debe ser un **módulo/plugin desacoplado**, compatible con:
- app funcionando **sin** el plugin,
- app funcionando **con** el plugin,
- app funcionando con **este plugin y otros plugins simultáneamente**.

---

## 1) Requisitos de modularidad (Arquitectura tipo Plugin)

### 1.1 Requisito principal
El módulo de estadísticas **NO debe acoplarse** al núcleo del producto (core) ni depender directamente de implementaciones concretas del storage, navegación o modelos internos.

### 1.2 Mecanismo de desacoplamiento (obligatorio)
Implementa el plugin usando **Protocolos + Inyección de Dependencias + Adaptadores**.

- El plugin expone **interfaces públicas mínimas** (protocolos/entrypoints).
- El core **inyecta** dependencias al plugin (repositorios/servicios) mediante protocolos.
- El plugin **no importa** módulos internos no públicos del core. Solo depende de:
  - Swift standard libs
  - frameworks del proyecto ya usados
  - y (si existe) un módulo `Core`/`AppKit`/`Shared` público del proyecto.

### 1.3 Integración sin aumentar acoplamiento
El core NO debe conocer detalles internos del plugin. Debe tratarlo como una “caja” que:
- puede aportar **1 TabItem** (o 1 screen) a la navegación principal,
- puede registrar dependencias en un contenedor DI (si existe),
- puede ser habilitado/deshabilitado por configuración.

> Si el proyecto ya tiene un sistema de módulos/plugins, úsalo.

---

## 2) Definiciones clave (para cálculos y UI)
### 2.1 Expected (Esperados)
Cantidad de veces que **debería** completarse un hábito en un periodo, según su programación real.

Ejemplo: hábito semanal “martes”
- Día martes: expected=1, otros días: expected=0
- Semana: expected=1
- Mes: expected = número real de martes en ese mes
- Año: expected = número real de martes en ese año (usando calendario)

### 2.2 Completed (Completados)
Cantidad de completions registradas en el periodo.
- Si la app actual limita “1 completion por ocurrencia/día”, respétalo.
- Si la app permite múltiples completions por día/hábito, adapta el cálculo para sumar counts.

### 2.3 Cumplimiento
`completionRate = completed / expected`
- Si expected=0: mostrar “—” (no aplica) y no penalizar.

### 2.4 Hábito activo en periodo
Hábito cuyo rango de vigencia intersecta el periodo (inicio/fin/archivado según lógica existente).

---

## 3) UI/UX — Requisitos funcionales exactos

### 3.1 Pantalla: StatsOverviewScreen (nueva pestaña “Estadísticas”)
Orden de secciones (de arriba a abajo):

#### A) Selector de fecha de referencia
- Control para elegir “fecha de referencia” (por defecto: hoy).
- Al cambiar la fecha, actualiza los 4 previews:
  - Diario: ese día
  - Semanal: semana que contiene esa fecha
  - Mensual: mes que contiene esa fecha
  - Anual: año que contiene esa fecha

#### B) Resumen global del periodo seleccionado (rápido)
- Bloque compacto con:
  - Completed/Expected del periodo seleccionado (default: semanal)
  - % Cumplimiento
  - Racha actual (definición sección 6.4)
- Un selector simple (tabs/segmented/picker) para elegir “periodo activo” SOLO para este resumen y la mini visualización.

#### C) Grid de 4 Recap Cards (principal)
4 cards: Diario / Semanal / Mensual / Anual.
Cada card muestra exactamente:
1) Título + rango (ej. “Semana · 6–12 Ene”)
2) KPI: % Cumplimiento (o “—”)
3) Completados vs Esperados: `completed / expected`
4) Highlight (1 línea)

Tap en card → abre `RecapDetailScreen(period)`.

#### D) Mini visualización rápida (según periodo seleccionado en B)
- Diario: barras por hábito (top 5) con completado (0/1 o count)
- Semanal/Mensual: barras por día con completed vs expected
- Anual: barras por mes con completed vs expected

> Visualización limpia y profesional. Máximo 1 gráfico.

---

### 3.2 Pantalla: RecapDetailScreen(period)
Secciones (de arriba a abajo):

1) Header
- Título (Recap Diario/Semanal/Mensual/Anual)
- Rango
- KPI grande: % + completed/expected

2) Highlights (2–3)
- highlight principal + 1–2 secundarios (si hay datos)

3) Visual principal (según periodo)
- Diario: lista de hábitos esperados del día con estado
- Semanal: gráfico 7 días completed vs expected
- Mensual: calendario interactivo del mes + panel/screen de detalle del día (obligatorio)
- Anual: gráfico 12 meses completed vs expected

4) Breakdown por hábito (ranking)
- Lista ordenada por completados (default)
- Cada fila: nombre + completed/expected + % + badge “top/riesgo” (si aplica)

5) Comparación con periodo anterior (si existe)
- delta % + delta completados + trendLabel

---

### 3.3 Mensual: Calendario interactivo (obligatorio)
- Calendario grid del mes (semana x días).
- Cada día muestra estado:
  - expected=0 → neutro
  - expected>0 y completed=0 → fallido
  - completed==expected → perfecto
  - 0<completed<expected → parcial
- Tap en un día → abre DayDetail (panel o screen):
  - Completed/Expected del día
  - Lista de hábitos esperados del día con estado
  - Opcional: CTA “Ir al hábito” (si existe ruta/pantalla)

---

## 4) Highlights (mensajes) — implementación determinística

### 4.1 Restricciones
- 1 línea, ~60 caracteres máximo.
- Determinístico basado en datos.
- Localizable.

### 4.2 Reglas (prioridad)
Selecciona el primero que aplique:

1) Perfecto
- if completionRate == 1 && expected > 0
- “Perfecto: completaste todo lo esperado”

2) Buen rendimiento
- if completionRate >= 0.8 && expected > 0
- “Muy bien: gran constancia en este periodo”

3) Necesita empuje
- if completionRate > 0 && completionRate < 0.5
- “Toca retomar: poco cumplimiento este periodo”

4) Sin datos aplicables
- if expected == 0
- “Sin hábitos programados para este periodo”

5) Patrón específico (si disponible)
- bestWeekday claramente mayor → “Tu mejor día fue: {X}”
- topHabit → “Hábito MVP: {nombre}”

En preview: 1 highlight.  
En detalle: 2–3.

---

## 5) Estadísticas a trackear (exactas y dónde se muestran)

### 5.1 Base (Preview + Header detalle)
- completedTotal(period)
- expectedTotal(period)
- completionRate(period)
- activeHabitsCount(period) → detalle
- habitsWithCompletionCount(period) → detalle
- habitsNeverCompletedCount(period) → detalle

### 5.2 Por hábito (Breakdown)
- completedByHabit
- expectedByHabit
- rateByHabit
- topCompletedHabit
- mostConsistentHabit (mejor rate con expected>0)
- mostAbandonedHabit (expected alto + rate bajo)

### 5.3 Por día (Visuales)
- completedByDay
- expectedByDay
- perfectDaysCount
- failedDaysCount
- bestWeekday
- worstWeekday

### 5.4 Rachas
- currentStreak
- bestStreak

**Definición de racha (requisito):**
Racha de **días perfectos consecutivos**:
- Día perfecto: expectedDay>0 && completedDay==expectedDay
- expectedDay==0 no rompe racha (se ignora)
- expectedDay>0 && completedDay<expectedDay rompe racha

### 5.5 Comparativas
- previousPeriodCompletionRate
- deltaCompletionRate
- deltaCompletedTotal
- trendLabel:
  - deltaRate >= +0.05 → Mejorando
  - -0.05 < deltaRate < +0.05 → Estable
  - deltaRate <= -0.05 → Empeorando

---

## 6) Casos límite (UI)
- expectedTotal=0:
  - % = “—”, ratio “0/0”
  - highlight “Sin hábitos programados…”
  - visual vacío con texto informativo
- no hay hábitos activos:
  - Overview muestra estado vacío + CTA “Crear hábito”
- sin periodo anterior:
  - ocultar bloque de comparación

---

## 7) Requisitos de implementación (Swift + MVVM)

### 7.1 MVVM obligatorio
Para cada pantalla:
- View (SwiftUI View o UIViewController según proyecto)
- ViewModel con:
  - estado observable (loading/success/empty/error)
  - inputs de usuario (fecha, periodo seleccionado, taps)
  - outputs (models listos para UI)

### 7.2 Cálculo y data flow
- El plugin debe calcular stats a partir de:
  - hábitos (con schedule y vigencia)
  - completions/events (por timestamp)
- Debe usar `Calendar`/timezone consistente con la app (revisar settings existentes).

### 7.3 Performance
- Cálculos deben ser eficientes:
  - cache por periodo + fecha de referencia (si el repositorio es pesado)
  - evitar recomputar todo innecesariamente al cambiar de pantalla
- No bloquear UI thread.


---

## 8) Desacoplamiento real: contratos (protocolos) y adaptadores

### 8.1 El plugin NO debe acceder directamente al storage actual
En su lugar, define protocolos de entrada (en el plugin o en un módulo shared si ya existe):

- `HabitStatsDataSource` (o equivalente): obtiene hábitos con schedule y vigencia.
- `CompletionStatsDataSource`: obtiene completions en un rango de fechas.

El core provee implementaciones concretas mediante adaptadores:
- `CoreHabitRepositoryAdapter: HabitStatsDataSource`
- `CoreCompletionRepositoryAdapter: CompletionStatsDataSource`

> Si ya existen repositorios en el core, NO los muevas: crea adaptadores.

### 8.2 El plugin no debe introducir cambios de modelo globales
- No modificar modelos core salvo que sea estrictamente necesario.
- Si es necesario tocar el core, hazlo mínimo y **documenta los cambios** al final (ver sección 11).

---

## 9) Inyección del plugin en la app principal (sin acoplamiento)

### 9.1 Si ya existe un sistema de plugins/módulos
- Registra el plugin allí.
- El core solo conoce un protocolo tipo `AppPlugin`/`FeatureModule`.

### 9.2 Si NO existe
Implementa un **Plugin Host mínimo**, con el menor cambio al core, por ejemplo:

- Un protocolo público en el core (o módulo shared) tipo:
  - `AppFeaturePlugin` que expone:
    - `id`
    - `makeTabItem(...)` o `makeRootScreen(...)`
    - `registerDependencies(container)` si hay DI

- Un registro en el App start:
  - array `[AppFeaturePlugin]`
  - composición de tabs a partir de plugins habilitados

**Requisito clave:**  
El core no debe importar el plugin directamente “por todos lados”. Solo en un punto de composición (App bootstrap / DI assembly).

### 9.3 Feature flag / configuración de habilitado
Debe existir una forma de habilitar/deshabilitar plugins:
- configuración (build flag, runtime config, remote config si existe, o simple array)
- Si el plugin está deshabilitado:
  - no aparece la pestaña “Estadísticas”
  - no se inicializan sus viewmodels/servicios

---

## 10) Entregables (archivos/piezas a crear)

### 10.1 Dentro del plugin “StatisticsPlugin”
- EntryPoint del plugin (ej. `StatisticsPlugin` conformando `AppFeaturePlugin`)
- StatsOverviewScreen + VM
- RecapDetailScreen + VM
- Monthly Calendar UI + DayDetail UI + VM (o sub-VM)
- Dominio:
  - modelos de recap (Preview/Detail)
  - calculadora de expected/completed/racha
  - generador de highlights
- Protocolos de datasources (entrada)
- Tipos auxiliares: period intervals, date formatting, etc.

### 10.2 En el core (si y solo si hace falta)
- Punto único de composición/registro del plugin
- Adaptadores a datasources

---

## 11) Regla de documentación de cambios al core
Si necesitas tocar el producto base (core), **NO lo expliques inline** en medio del trabajo.  
Al final de tu implementación, entrega una sección:

### “Cambios realizados en el core”
- lista de archivos modificados
- por qué fue necesario
- por qué no aumenta el acoplamiento
- cómo se mantiene compatible con otros plugins

---

## 12) Checklist de aceptación (QA)
- [ ] App compila y corre sin el plugin (plugin deshabilitado).
- [ ] App compila y corre con el plugin habilitado.
- [ ] Pestaña “Estadísticas” aparece solo si el plugin está habilitado.
- [ ] Overview muestra selector de fecha, resumen, 4 recap cards, mini visual.
- [ ] Cada card abre su RecapDetail correcto.
- [ ] Mensual tiene calendario interactivo + day detail.
- [ ] Stats respetan expected/completed según schedule real.
- [ ] Racha cumple definición exacta.
- [ ] Comparativas con periodo anterior funcionan cuando hay datos.
- [ ] Estados vacíos correctos (expected=0, sin hábitos).
- [ ] UI consistente con el estilo del proyecto.

---

## 13) Output esperado del agente (Codex)
Implementa todo lo anterior en el repositorio:
1) Crea el plugin/module y su entrypoint.
2) Integra el plugin en la app con DI y plugin host (usando el sistema existente o creando el mínimo).
3) Asegura que el core solo tiene un punto de composición y adaptadores por protocolo.
4) Al final, incluye la sección “Cambios realizados en el core” con detalle. Genera esto tambien como un informe markdown explicando todo lo anterior
y explicar cómo tu código está desacoplado y responder a la Pregunta clave: ¿Cómo se inyecta tu código en la app principal sin aumentar el
acoplamiento del núcleo? (Patrones, Protocolos, Inyección de Dependencias).
